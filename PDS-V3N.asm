;      NAM     PDS-V3N
;      OPT     0,NOG
;
;
;
;      PROGRAMMED BY ERIC JAMESON
;
;
;
;      COPYRIGHT 1976 SPHERE CORPORATION
;      940 N.  400 EA.;  NORTH SALT LAKE, UTAH 84054
;
;
;
;      SPHERE RESERVES ALL RIGHTS FOR THE REPRODUCTION,
;      DISTRIBUTION AND USE OF THE PDS SOFTWARE.
;      NO COPIES MAY BE MADE OR DISTRIBUTED WITHOUT THE
;      WRITTEN PERMISSION OF SPHERE CORP.
;
;
;
;
; THE PROGRAM DEVELOPMENT SYSTEM (PDS V3N) IS A SET OF
; PROGRAMS RESIDING ON ERASABLE PROGRAMMABLE READ ONLY
; MEMORY WHICH ALLOW EVEN THE SMALLEST USER TO USE HIS
; SPHERE SYSTEM AS A COMPLETE COMPUTER SYSTEM FOR THE
; DEVELOPMENT OF COMPUTER PROGRAMS.
;     TOWARD THIS END, THE 4 PDS EPROMS CONTAIN A CURSOR
; BASED EDITOR, A MINI-ASSEMBLER, AND THE SPHERE DEBUGGING
; AID (SDA), AS WELL AS A SET OF UTILITY ROUTINES TO DO 16
; BIT MULTIPLY AND DIVIDE, ASCII-TO-BINARY, AND
; BINARY-TO-ASCII ROUTINES.
;
;
;
;     THE PDS-V3N PROM SET WAS WRITTEN IN ORDER TO RUN THE
; NEW KEYBOARD.  CHANGES WERE MADE IN THE EDITOR AND THE
; DEBUGGER.  AS THE NEW PROMS ARE A GREAT IMPROVEMENT OVER
; THE V3A PROMM SET, A VERSION KNOWN AS PDS-V3D WAS MADE
; WOULD RUN IN THE OLD KEYBOARDS.  THE ONLY DIFFERENCE
; BETWEEN THE V3D AND THE V3N PPROMS ARE THAT THE PIA
; ADDRESS IS CHANGED FROM F040 ON V3N TO F000 ON V3D.
; CHANGES WERE ALSO MADE IN THE DEBUGGER AND THE
; EDITOR.  THE EDITOR CHANGES WERE THAT INSERT AND DELETE
; ARE NOW AT THE TOP OF THE PAGE AND THAT THERE IS A REEDIT
; COMMAND IN THE EXEC (CTRL A) TO ALLOW RE-EDITING.  THE
; ENTRY TO THE DEBUGGER FROM THE BREAKPOINT INSTRUCTION
; HAS BEEN CHANGED SO THAT THE RETURN ADDRESS FOR THE
; BREAKPOINT IS NOW CALCULATED WHEN THE BREAKPOINT IS
; ENCOUNTERED AND GOES TO THE DEBUGGER.  IN ADDITION
; THERE ARE 2 NEW INSTRUCTIONS.  ^J FOR DOING A JSR TO
; A ROUTINE AND ^X TO EXIT BACK TO THE EXEC.
;

        .CR 6800                ; LOAD MC6800 CROSS OVERLAY
        .TF PDSV3N.bin,BIN         ; OUTPUT FILE TO TARGET.BIN IN BINARY FORMAT
        .OR $FC00               ; START OF ASSEMBLY ADDRESS
        .LI OFF                 ; SWITCH OFF ASSEMBLY LISTING (EXCEPT ERRORS)

;                MEMORY MAP
;
TMP     .EQU     $00
TMP1    .EQU     $02
ARB     .EQU     $04         ; 16 BIT ACC. PSEUDO REG B.
AR3     .EQU     $04         ; _HI BYTE OF ARB.
AR2     .EQU     $05         ; _LO BYTE OF ARB.
ARA     .EQU     $06         ; 16 BIT ARITH PSEUDO REG A.
AR1     .EQU     $06         ; _HI BYTE OF ARA.
AR0     .EQU     $07         ; _LO BYTE OF ARA.
DIGIT   .EQU     $08         ; BYTE USED BY ASCBIN FOR TEMP.
OUTEND  .EQU     $0A         ; END OF OUTPUT BUFFER TEXT.
BUFADR  .EQU     $0C         ; START OF I/O BUFFER (PTR)
BUFEND  .EQU     $0E         ; PTR. TO END OF I/O BUFFER.
OUTBUF  .EQU     $11         ; START OF OUTPUT BUFFER.
SRCADR  .EQU     $14         ; SOURCE FOR TEXT MOVES.
DSTADR  .EQU     $16         ; DEST. ADDR. FOR TEXT MOVE.
ENDMEM  .EQU     $1A         ; LAST ADDRES OF REAL MEMORY.
CSRPTR  .EQU     $1C         ; PTR TO CURSER ON SCREEN.
BUFPTR  .EQU     $1E         ; TEMP PTR USED BY OUTSTR.
BUFFLO  .EQU     $20         ; PTR TO END OF LOW EDIT TXT.
BUFFHI  .EQU     $22         ; PTR TO START OF HI TEXT.
SCNPTR  .EQU     $24         ; PTR. TO BUFFRD TXT START. 
SRCASM  .EQU     $26         ; PTR TO ASSMBLR SOURCE CODE.
ONDVAL  .EQU     $2A         ; HAS ASSMBLR OPERND VALUE.
SYMVAL  .EQU     $2C         ; VALUE OUT IN ASSM. SYMTBL.
BRKSAV  .EQU     $2E         ; TEMP SAVE FOR BRKPT DATA.
BRKADR  .EQU     $30         ; ADDDRESS OF BREAKPOINT.
EDIT    .EQU     $32         ; 0 IF EDITOR IS NOT RUNNING.
IOBUFF  .EQU     $35         ; I-O BUFFER FOR DEBUGGER.
PCVAL   .EQU     $40         ; PROGRAM COUNTER FOR ASSM.
;
FRSTLN  .EQU     $E01F       ; RIGHTMOST CHAR OF LINE ONE.
LASTLN  .EQU     $E1E0       ; LEFT SIDE OF BOTTOM OF CRT.
LASTCH  .EQU     $E1FF       ; LAST CHAR ON CRT DISPLAY.
KBDPIA  .EQU     $F040       ; ADDRESS OF PIA FOR KBD/2.
;KEYBOARD PIA ADDRESS FOR OLD KEYBOARD (KBD/1A) IS F000.

;INPCHR  EQU     $FE71       ; INPUTS A CHARACTER.
;DEBUG   EQU     $FE64       ; DEBUGGER ROUTINE.
;ASCBIN  EQU     $FF22       ; ASCII TO BINARY ROUTINE.

;              INITIALIZATION
;
;
;
;   THE INITIALIZATION ROUTINES SET UP THE INITIAL VALUES
; UPON SYSTEM RESET.
;
;
        ;ORG     $FC00
RESTRT  LDS     #$1FF       ; SETS STACK POINTER
        TSX                 ; MOVES STK PTR TO INDEX REG
        STX     SRCASM      ; SETS ASSEMBLR OUTPUT PTR
        STX     BUFADR      ; INIT INPUT BUFFER ADDR.
        LDAA    #$1F        ; INTLZ. KEYBOARD PIA.
        STAA    KBDPIA+1    ; PIA CONTROL REG. ADDRESS.
        LDX     #$FFF       ; LAST LOCATN OF MEMORY.
        STX     BUFEND      ; INIT END-OF-EDIT BUFFR.
        STX     ENDMEM      ; INIT END-OF-MEM ADDR.
;
;
;
;
;
;              COMMAND LANGUAGE
;
;    THIS EXECUTIVE ACCEPTS COMMANDS FROM THE KEYBOARD TO
; DETERMINE WHAT UTILITY IS TO BE RUN.  INVALID COMMANDS
; WILL SPACE THE CURSOR DOWN ONE LINE. DO NOT SPACE OFF THE
; BOTTOM OF THE SCREEN.
;
;
EXEC    BSR     HOME        ; CSRPTR IS HOMED.
        BSR     CLEAR       ; CLEARS SCREEN
EXEC1   BSR     CR1         ; CRLF FOR NEW LINE.
        JSR     INPCHR      ; GETS & DISPLAYS CHR.
        CMPA    #$01        ; TESTS IF ASSEMBLY COMMD.
        BNE     EXEC2       ; SKIPS IF OTHER COMMAND.
        JSR     ASMBLR      ; JUMPS TO ASSEMBL PRROGRM.
EXEC2   CMPA    #$05        ; TESTS IF CONTRL 'E'.
        BNE     EXEC3       ; SKIPS IF NOT EDIT CMD.
        BSR     EDITOR      ; JUMPS TO EDIT TEXT.
EXEC3   CMPA    #$12        ; TESTS FOR A ^R COMMAND.
        BNE     EXEC4       ; SKIPS IF NOT A REEDIT COMND.
        BSR     REEDIT      ; GOES TO REEDIT TEXT.
EXEC4   CMPA    #$04        ; TESTS FOR CONTRL 'D'.
        BNE     EXEC1       ; SKIPS BACK FOR A NEW COMND.
        JMP     DEBUG       ; JUMPS TO DEBUGGER
        
;              THE EDITOR
;
;
;     THE EDITOR ALLOWS INPUT FROM THE KEYBOARD INTO A
; BUFFER MEMORY.  INPUT IS DISPLAYED ON THE SCREEN.  WHEN
; IT IS TYPED IN, THE SCREEN TEXT CAN THEN BE EDITED BY USE
; OF THE CURSOR.  WHEN THE SCREEN IS FULL OR EDITING IS
; FINISHED, THE DATA IS SCROLLED OFF THE SCREEN INTO THE
; EDIT BUFFER.  WHEN TEXT IS SCROLLED OFF THE TOP OF THE
; SCREEN, IT IS STORED FROM THE BUFFER ADDRESS POINTER
; (BUFADR) TO THE LOW BUFFER POINTER (BUFFLO).  BUFFLO
; POINTS TO THE END OF TEXT + ONE (I.E. IT POINTS TO THE
; FIRST UNUSED BYTE).  WHEN IT IS SCROLLED OFF THE BOTTOM
; OF THE SCREEN, IT IS STORED IN THE TOP OF THE EDIT BUFFER.
; THE TEXT GOES FROM THE HIGH BUFFER POINTER (BUFFHI) TO
; THE END OF BUFFER POINTER (BUFEND).  BUFFHI POINTS TO
; THE END OF TEXT - ONE (I.E. IT POINTS TO THE LAST UNUSED
; BYTE OF THE BUFFER).  WHEN THE TEXT IS SCROLLED UP
; OFF THE TOP OF THE SCREEN, TEXT IS TAKEN FROM THE HIGH
; AREA OF THE EDIT BUFFER AND DISPLAYED ON THE LAST LINE OF
; THE SCREEN.  WHEN TEXT IS SCROLLED DOWN OFF THE BOTTOM,
; TEXT, IF ANY EXISTS, IS MOVED FROM THE LOW EDIT BUFFER 
; AREA TO THE TOP LINE OF THE SCREEN.
;
;
;
;
;
;
;
;
;
;
;               POINTERS USED
;
; CSRPTR   POSITION OF CHARACTERS INSERTED ON THE SCREEN.
; SCNPTR   POSITION OF START OF EDITED TEXT ON SCREEN.
; BUFADR   START OF TEXT BUFFER IN MAIN MEMORY.
; BUFEND   END OF TEXT BUFFER IN MAIN MEMORY.
; BUFFLO   END OF TEXT SCROLLED OFF TOP OF SCREEN.
; BUFFHI   START OF TEXT SCROLED OFF BOTTOM OF SCREEN.
; BUFLEN   NOT CURRENTLY USED.
;
;
;
;
;
;             EDITOR COMMANDS
;
; "UP ARROW"  MOVES CURSOR UP ONE LINE; CSRPTR GETS
;  CSRPTR-32; CALL NDRFLO.
;
; "DOWN ARROW"  MOVES CURSOR DOWN ONE LINE; CSRPTR GETS
;  CSRPTR+32; CALL OVRFLO.
;
; "RIGHT ARROW"  MOVES CURSOR ONE POSITION RIGHT; CSRPTR
;  GETS CSRPTR+1; CALL OVRFLO.
;
; "LEFT ARROW"  MOVES CURSOR ONE POSITION LEFT; CSRPTR
;  GETS CSRPTR-1; CALL NDRFLO.
;
; "CONTROL & LEFT ARROW (ON KEYBOARD)"  LEFT JUSTIFY CURSOR;
;  CSRPTR GETS CSRPTR TRUNCATED; CALL NDRFLO FOR SCNLOC CHK.
;
; "PUTCHR"  OUTPUTS CHARACTER; CSRPTR GETS
; CSRPTR+1;  GOES TO OVRFLO.
;
; "ENDCHR"  TERMINATION CHAR; CLEAR EDIT FLAG;
;  EXIT THE EDITOR.
;
; "HOME"  HOMES CURSOR POINTER; CSRPTR GETS E000; NDRFLO.
;
; "CLEAR"  CSRPTR TO END OF THE SCREEN GETS SPACES.
;
; "CTRL I"  INSERT A LINE AT THE LAST LINE ON THE SCREEN;
;  CALL OVR1 (SCROLLS UP ONE LINE); CSRPTR GETS E1E0.
;
; "CTRL D"  DELETE LAST LINE; SCROLL DOWN (UNDR2);
;  CSRPTR GETS E1E0.
;
;
;
;
; OVERFLOW CHECKS IF SCROLL UP IS NEEDED; IF IT IS, IT
;  SCROLLS UP AND MOVES DATA TO & FROM THE BUFFEERS.
;
; OVRFLO: IF CSRPTR < E200 THEN RETURN; IF EDIT IS ON THEN
; OVR1:   BUFFLO+ GETS SCNPTR TO 'C.R.';
; DSTADR GETS CSRPTR GETS E1E0 (LAST LINE ON SCREEN);
; IF EDIT IS ON AND BUFFHI < BUFEND THEN MOVE THE TEXT
; (THE STRING FROM BUFFHI TO 'C.R.') TO THE LAST LINE.
;
;
;
;
; UNDERFLOW CHECKS IF SCROLL DOWN IS NEEDED AND MOVES
;  DATA TO AND FROM THE BUFFERS.  CURSOR HAD BEEN
;  MOVED OFF THE TOP OF THE SCREEN AND IS NOW PUT AT THE
;  HOME POSITION ON THE SCREEN.
;
; NDRFLO:  IF CSRPTR > DFFF THEN RETURN (GO TO OVRFLO);
;  IF EDIT FLAG IS ON THEN MOVE LAST LINE TO BUFFHI
;   ON DOWN; SCRLDN; CSRPTR GETS E000; MOVE LINE FROM
;   BUFFLO TO FIRST LINE ON THE CRT.
;
;
;
;
;  NOTE:   DON'T SCROLL OFF SCREEN IN EXEC UNTIL AFTER
;    THE EDITOR HAS BEEN RUN.
;
;  NOTE:   EVERY LINE MUST HAVE A C.R. ON IT.

HOME    LDX     #$E000      ; LOADS HOME POSITION.
        STX     CSRPTR      ; STORES HOME IN CURSOR PTR.
        RTS
;
;
CLEAR   LDAB    #$60        ; LOADS BLANK (C.R.).
        LDX     #LASTCH+1   ; LOADS END-OF-SCREEN PTR.
CLEAR1  DEX                 ; DECREMENTS BLANKING PTR.
        STAB    0,X         ; BLANKS LOCATION.
        CPX     CSRPTR      ; TESTS IF DONE.
        BNE     CLEAR1      ; BRANCHES BACK IF NOT DONE.
        RTS                 ; RETURNS.
;
;
;
;       GETCHR INPUTS A CHARACTER INTO ACC A WITHOUT
;       MOVING THE CURSOR, AND BLINKS THE CURSOR.
;
GETCHR  LDX     CSRPTR      ; LOADS CRT CURSOR POSITION.
        COM     0,X         ; COMPLIMENT (FLASH POSITION).
        LDX     #9968       ; LOADS BLINK COUNT VALUE.
GET1    DEX                 ; COUNT GETS COUNT-1.
        BEQ     GETCHR      ; RESETS CTR WHEN TIMED OUT.
        LDAA    #$40        ; LOADS MASK FOR CA2 FLAG.
        BITA    KBDPIA+1    ; TESTS IF A CHAR. TYPED IN.
        BEQ     GET1        ; BRANCH IF CHAR NOT ENTERED.
        LDX     CSRPTR      ; LOADS CURSOR POSITION.
        LDAA    0,X         ; TESTS IF BLINKMD (SOLID).
        BPL     GET2        ; SKIPS OF NOT BLINKED.
        COM     0,X         ; CLEARS THE CHARACTER.
GET2    LDAA    KBDPIA      ; LOADS A WITH KEYBRD CHAR.
        RTS                 ; RETURN TO CALLER.
;
;
;
;
;        EDITOR IS THE MAIN ENTRY POINT FOR EDITING.
;
EDITOR  LDX     BUFADR      ; BUFFLO GETS THE
        STX     BUFFLO      ; VALUE OF BUFADR.
        LDX     BUFEND      ; BUFFHI GETS THE
        STX     BUFFHI      ; VALUE OF BUFEND.
REEDIT  BSR     HOME        ; ENTRY POINT FOR
        BSR     CLEAR       ; RE-EDITING TEXT.
EDITRD  STAA    EDIT        ; TURNS ON EDIT MODE.
EDITIN  LDX     CSRPTR      ; SETS SCNPTR TO CSRPTR.
        STX     SCNPTR
;
;
EDREAD  BSR     GETCHR      ; X GETS CSRPTR & A GETS CHAR.
ENDCHR  CMPA    #$1B        ; TESTS FOR AN "ESC" CHAR.
        BNE     ED1         ; SKIPS IF NOT EDIT END.
        CLR     EDIT        ; TURNS OFF EDIT FLAG.
        RTS                 ; EXITS THE EDITOR.
ED1     BSR     INSERT      ; EDITS CHARACTER.
        BRA     EDREAD      ; GOES FOR NEXT CHARACTER.

;
;
;       FOLLOWING IS THE MAIN EDITOR EXECUTION LOOP.
;
;
;
;
;
CR      CMPA    #$0D        ; TESTS FOR CARRIAGE RETURN.
        BLT     HOME        ; SKIPS IF HOME CURSR COMND.
        BGT     RTCSR       ; GOES TO NEXT COMND TEST.
CR1     LDAA    #$60        ; LOADS INTERNAL C.R. VALUE.
;
;
;
;
INSERT  CMPA    #$09        ; TESTS FOR A CONTROL 'I'.
        BLT     DELETE      ; SKIPS TO DELETE COMND.
        BGT     CR          ; SKIPS FOR NEXT TEST.
INSRT1  LDAB    EDIT        ; TESTS IF EDITOR IS ON.
        BEQ     INSRT2      ; SKIP TO EXIT IF EDITOR OFF.
        JSR     MOVE2       ; MOVES LAST LINE TO BUFFHI
INSRT2  JMP     SCRLDN      ; MOVES ALL LINES DOWN ONE.
;
;
;
RTCSR   CMPA    #$12        ; TESTS FIR RIGHT ARROW.
        BLT     SUB32       ; SKIPS IF AN "UP ARROW".
        BGT     LFTCSR      ; SKIPS IF A "LEFT ARROW".
RTARRO  LDX     CSRPTR      ; LOADS CURSOR POINTER.
        BRA     PUTCH1      ; STORES & INCREMENTS CSR.
;
;
;
DELETE  BSR     OVR1A       ; SCROLLS UP ONE LINE.
        BRA     OVR3        ; NOVES NEW LAST SCREEN LINE.
;
;
;
LFTCSR  CMPA    #$14        ; TESTS IF "LEFT ARROW".
        BLT     ADD32       ; SKIPS IF "DOWN ARROW".
        BGT     CLER        ; SKIPS FOR NEXT TEST.
        DEX                 ; SUB. 1 FROM CSRPTR.
        BRA     ADD2        ; STORES CURSOR POINTER.
;
;
;
CLER    CMPA    #$1F        ; TESTS FOR CTRL BACK ARROW.
        BLT     CLEAR       ; GOES TO CLEAR SCREEN.
        BEQ     LFTJST      ; MOVES CSR TO LEFT OF SCREEN.
;
;
; ALL OTHER CHARACTERS FALL THRU TO PUTCHR.
;

;       PUTCHR DISPLAYS A CHARACTER ON THE CRT DISPLAY AND
;         INCREMENTS THE CURSOR POINTER AS WELL AS CHECKING
;         AND HANDLING CARRIAGE RETURNS.
;
;
;
PUTCHR  LDX     CSRPTR      ; LOADS OLD CSRPTR.
        CMPA    #$0D        ; TESTS FOR EXTERNAL C.R.
        BEQ     CRLF1       ; SKIPS TO DO A C.R. L.F.
        STAA    0,X         ; DISPLAYS CHAR ON SCREEN.
        CMPA    #$60        ; TESTS FOR INTERNAL C.R.
CRLF1   BEQ     CRLF        ; SKIPS FOR CR. LF.
PUTCH1  INX                 ; INCREMENTS CSRPTR.
        BRA     ADD2        ; TESTS FOR OVRFLO & UNDRFLO.
        
SUB32   LDX     CSRPTR      ; LOADS CURRENT CRSR POSITION.
        LDAB    #32         ; LOADS LOOP COUNT.
SUB32A  DEX                 ; DECREMENTS CSRPTR.
        DECB                ; DECREMENTS LOOP COUNTR.
        BNE     SUB32A      ; SKIPS BACK IF NOT DONE.
        BRA     ADD2        ; SKIPS TO CHECK UNDRFLO.
        
ADD32   LDAB    #32         ; LOADS LOOP COUNTER.
ADD32A  INX                 ; INCRE. CSRPTR IN INDEX.
        DECB                ; DCEREMENTS LOOP COUNTER.
        BNE     ADD32A      ; SKIPS BACK IF NOT DONE.
ADD2    STX     CSRPTR      ; SAVES CSRPTR.

; NDRFLO (UNDERFLOW) CHECKS FOR THE CURSOR GOING OFF THE
;  TOP OF THE SCREEN. THE INDEX REG  CONTAINS THE CURSOR 
;  POINTER WHEN THE ROUTINE IS ENTERED.
;
;
NDRFLO  CPX     #$E000      ; TESTS IF CSRPTR >= DFFF.
        BGE     OVRFLO      ; SKIPS IF CSRPTR GREATER.
        BSR     INSRT1      ; SCROLLS DOWN & MOVES LINE.
        BSR     MOVE3       ; MOVES BUFFLO TO TOP OF CRT.

;
;
;     OVERFLOW CHECKS FOR SCROLLING UP (CURSOR IS OFF
; THE BOTTOM OF THE SCREEN); INDEX CONTAINS THE CURSOR
; POINTER UPON ENTRY.
;
;
OVRFLO  CPX     #$E200      ; TESTS AND EXITS IF
        BMI     OVREXT      ; CURSOR ON SCREEN.
        BSR     OVR1        ; DOES OVR1 CHECKING.
OVR3    LDAB    EDIT        ; TESTS IF EDIT IS ON.
        BEQ     OVREXT      ; EXITS IF IT IS OFF.
        LDX     BUFFHI      ; LOADS HI TEXT POINTR.
        CPX     BUFEND      ; TESTS IF PTRS NOT EQU.
        BEQ     OVREXT      ; EXITS IF NO TEXT.
        BSR     MOVE1A      ; MOVES CHRS TO LAST LINE.
        LDX     SRCADR      ; RESETS NEW BUFFHI
        STX     BUFFHI      ; LOCATION.
;
;
;
;
;       FOLLOWING ROUTINE MOVES THE CURSOR TO THE LEFT.
;
LFTJST  LDAB    CSRPTR+1    ; LOADS LOW BYTE OF PTR.
        ANDB    #$E0        ; TRUNCATES TO LEFT OF LINE.
        STAB    CSRPTR+1    ; SAVES L.J.ED PTR.
OVREXT  RTS                 ; RETURNS TO EDITOR.
;
;
;
;
;       OVR1 DOES ACTUAL SCROLLING UP.
;
OVR1    LDAB    EDIT        ; TESTS IF EDIT IS ON.
        BEQ     OVR1A       ; SKIPS IF EDIT OFF.
        LDX     BUFFLO      ; LOADS TEXT PTR LOW.
        STX     DSTADR      ; DESTINATION OF TEXT MOVE.
        LDX     SCNPTR      ; SOURCE FOR MOVE.
        BSR     MOVE1       ; MOVES LIN1 TO BUFFFLO.
        STX     BUFFLO      ; SAVES NEW BUFFLO PTR.
OVR1A   BRA     SCRLUP      ; SCROLLS SCREEN UP 1.

;       FOLLOWING ROUTINE MOVES THE CURSOR.
;
CRLF    BSR     ADD32       ; LINE FEED.
        BRA     LFTJST      ; CARRIAGE RETURN.

;     MOVE INSTRUCTIONS MOVE FROM ONE BUFFER AREA TO
; ANOTHER BUFFER AREA.
;
;
;
;     MOVE3 CALCULATES THE SOURCE ADDRESS OF THE DATA IN
; BUFFLO (IF IT EXISTS) FOR MOVING TO THE FIRST LINE ON
; THE CRT.  MOVE 1 IS THEN ENTERED TO DO THE MOVING.
;
;
MOVE3   LDX     SCNPTR      ; CSRPTR GETS E000 (HOME).
        STX     DSTADR      ; SETS MOVE ADDRESS.
        LDX     BUFFLO      ; LOADS LO BUFFR ADDR.
        CPX     BUFADR      ; TESTS IF STRING EXISTS.
        BEQ     MOVEXT      ; EXITS IF EMPTY.
        DEX
MV31    CPX     BUFADR      ; TESTS IF SRCADR = BUFFADR.
        BEQ     MV32        ; MOVES IF START OF LINE.
        DEX                 ; NEXT LOWER CHAR.
        LDAB    0,X         ; GETS SOURCE CHAR FOR TEST.
        CMPB    #$60        ; TESTS FOR "C.R.".
        BNE     MV31        ; SKIPS BACK UNTIL "C.R.".
        INX                 ; POINTS BACK TO FIRST CHAR.
MV32    STX     BUFFLO      ; SAVES LO ADDRESS.
        BRA     MOVE1       ; MOVES DATA.
        
;          MOVE1
;
;     MOVE1 MOVES A SET OF CHARACTERS FROM EITHER THE TOP
; LINE OF THE SCREEN TO BUFFLO OR FROM BUFFHI TO THE
; BOTTOM LINE OF THE SCREEN.  THE SOURCE ADDRESS IS PASSED
; IN THE INDEX REG.; THE DESTINATION ADDRESS IN DSTADR,
; AND THE MOVE IS TERMINATED BY A "C.R." IN THE LINE OF
; TEXT BEING MOVED.
;
;
;
;
MOVE    LDX     SRCADR      ; LOADS SOURCE ADDRESS INTO X. E
MOVE1A  INX                 ; POINTS TO NEXT SOURCE CHAR.
MOVE1   LDAB    0,X         ; LOADS SOURCE CHARACTER.
        STX     SRCADR      ; SAVES THE SOURCE POINTER.
        LDX     DSTADR      ; LOADS DESTINATION ADDRESS.
        STAB    0,X         ; STORES CHAR. IN DESTINATION.
        INX                 ; NEXT DESTINATION ADDRESS.
        STX     DSTADR      ; SAVES DESTINATION PTR.
        CMPB    #$60        ; TESTS IF MOVE FINISHED (CR).
        BNE     MOVE        ; SKIPS BACK IF NOT DONE.
MOVEXT  RTS                 ; RETURNS TO CALLER.

;          MOVE2 SUBROUTINE
;
;     THE MOVE2 SUBROUTINE MOVES THE LAST LINE ON THE
; SCREEN TO THE HIGH AREA OF THE BUFFER (BUFFHI) DURING
; SCROLLING.  THE TEXT IS TEMPORARILY STORED ON THE STACK
; DURING THE MOVE.  THE MOVE IS TERMINATED BY A "C.R.".
; THE TEXT IS STORED AT BUFFHI ON DOWN.
;
;
;
;
MOVE2   LDX     #LASTLN     ; X GETS ADDR OF LAST LINE.
        CLRB                ; SETS TERMINATION FOR
MV21    PSHB                ; STACK POPPING.
        LDAB    0,X         ; LOADS SOURCE CHAR.
        INX                 ; POINTS TO NEXT CHAR.
        CMPB    #$60        ; TESTS IF LINE TO "C.R."
        BNE     MV21        ; MOVED TO STACK.
MV22    LDX     BUFFHI      ; INIT. DESTINATION.
MV23    STAB    0,X         ; STORES CHAR.
        DEX                 ; POINTS TO NEXT LOCATION.
        STX     BUFFHI      ; UPDATES BUFFER PTR.
        PULB                ; GETS NEXT CHAR.
        CMPB    #00         ; TESTS IF ALL CHRS STORED.
        BNE     MV23        ; SKIPS BACK IF NOT STORED.
MOVEX   RTS                 ; RETURNS TO CALLER.

;       SCROLLUP MOVES ALL LINES UP 1, & CLEARS LAST LINE.
;
SCRLUP  LDX     #$E000      ; SETS CRT HOME POSITION.
SCRP1   LDAB    $20,X       ; GETS CAR FROM NEXT LINE.
        STAB    00,X        ; STORES CHAR ON PREV. LINE.
        INX                 ; POINTS TO NEXT LINE.
        CPX     #LASTLN     ; TESTS IF MOVE DONE.
        BNE     SCRP1       ; GOES BACK IF NOT DONE.
        STX     CSRPTR      ; SETS CSRPTR TO LAST LINE.
        STX     DSTADR      ; INIT DEST FOR NEXT MOVE.
        JSR     CLEAR       ; CLEARS LAST LINE.
        RTS                 ; EXITS.

;       SCRLDOWN MOVES ALL LINES DOWN ONE AND
; CLEARS THE TOP LINE ON THE SCREEN.
;
SCRLDN  LDX     #LASTLN-1   ; INITIALIZES THE POINTER.
SCRD1   LDAB    0,X         ; LOADS DATA TO BE MOVED.
        STAB    $20,X       ; MOVES DATA DOWN ONE LINE.
        STX     CSRPTR      ; SAVES CURSOR.
        DEX                 ; POINTS TO NEXT BYTE.
        CPX     #$DFFF      ; TESTS IF MOVE FINISHED.
        BNE     SCRD1       ; SKIPS BACK IF NOT DONE.
        LDAB    #$60        ; LOADS BLANK TO CLEAR LINE.
SCRD2   INX                 ; POINTS TO NEXT CHARACTER.
        STAB    0,X         ; CLEARS BYTE ON LINE 1.
        CPX     #FRSTLN     ; TESTS IF LINE 1 CLEARED.
        BNE     SCRD2       ; SKIPS BACK IF NOT CLEARED.
        RTS                 ; RETURNS.

;       OUTSTRING PRINTS OUT THE STRING BETWEEN THE
;       OUTBUF POINTER AND THE BUFEND POINTER.
;
OUTSTR  LDX     OUTBUF      ; BUFPTR GETS START OF TEXT.
OUT1    LDAA    0,X         ; LOADS CHAR TO BE PUT OUT.
        STX     BUFPTR      ; SAVES SOURCE POINTER.
        JSR     PUTCHR      ; PRINTS CHARACTER.
        LDX     BUFPTR      ; RESTORES POINTER.
        CPX     OUTEND      ; TESTS FOR END-OF-TEXT.
        BEQ     OUT2        ; EXITS IF END OF TEXT.
        INX                 ; INCRE, PTR TO NEXT CHAR.
        BRA     OUT1        ; GOES BACK FOR NEXT CHAR.
OUT2    RTS                 ; EXITS ROUTINE.
;
;       END OF EDITOR PROGRAM.
;

;          THE MINI-ASSEMBLER
;
;
;     THE MINI-ASSEMBLER IS A FIXED-FIELD ONE INSTRUCTION
; PER LINE 2 PASS ASSEMBLER.  THE MINI-ASSSEMBLER FORMAT
; IS DESCRIBED ON PAGES 9-2 AND 9-3 OF THE SPHERE
; OPERATORS REFERENCE MANUAL.
;     THE TWO PASSES ARE REQUIRED TO FORM THE LABEL
; ADDRESSES.  THE SECOND PASS EQUATES THE ADDRESS FOR
; LABELS REFRENCED BEFORE THEY ARE DEFINED IN THE PROGRAM.
;
;
; ON ENTRY:
; SRCASM = ADDRESS OF SOURCE TEXT TO BE ASSEMBLED.
; BUFFLO = ADDRESSED OF OBJECT CODE PRODUCED.
;
; ON EXIT:
; PCVAL (PROGRAM COUNTER VALUE) = LAST LOCATION OF
; THE ASSEMBLED OBJECT PROGRAM.
;
;
;
;
; ALGORITHM:
;
;ASMBLR:  SET PASS COUNT TO ZERO; SET PCVAL TO DSTASM;
;ASM1A:  OPERAND VALUE FORMED IN "ONDVAL":
; A GETS CHAR IN X6 (OPERAND TYPE); X GETS X+7;
; IF CHAR X6 IS A "@" THEN ONDVAL GETS VALUE FROM SYMBOL
;   TABLE ELSE ONDVAL GETS VALUE FROM ASCBIN CONVERSION;
;SYMBL:  EQUATES SYMBOL (PC VALUE IS THE " " SYMBOL
;[LABEL]) TO A LABEL VALUE:
; SYMVAL GETS PCVAL;
; IF X(1) IS AN "=" THEN SYMVAL GETS ONDVAL;
; IF X(1) IS NOT A "=" OR A SPACE THEN IF SECOND PASS THEN
;   EXIT ELSE START SECOND PASS;
; LABEL ENTRY IN SYMBOL TABLE GETS SYMVAL;
;LDOP:  PUT OPERATION CODE INTO THE OBJECT CODE:
; CONVERT X(2)-X(3) INTO BINARY;
; SAVE PCVAL;
; P.C. GETS P.C.+1;
;OPRND:  FORM OPERAND IN OBJECT CODE:
; FORM ONDVAL INTO PROPER SIZE BASED ON CODE IN X(6);
; STORE NEW OPERAND VALUE IN MEMORY;
; P.C. GETS P.C.+1 @@@@@
; GET NEXT LINE OF SOURCE;
; GO TO ASM1A;
;
;

ASMBLR  CLR     AR3         ; INIT. PASS CTR TO FIRST PASS.)
ASM1    LDX     BUFFLO      ; SETS PC CNTR TO START OF
        STX     PCVAL       ; OBJECT CODE.
        LDX     SRCASM      ; LOADS ADDR FOR FIRST LINE.
ASM1A   STX     TMP1        ; SAVES ADDR OF CURRENT LINE.
        LDAA    8,X         ; LOADS SYMBOL (LABEL).
        LDAB    7,X         ; LOADS OPERAND TYPE CODE.
        CMPB    #'@'        ; IF @, LOADS DATA IN SYMBOL
        BEQ     INDADR      ; ADDRESS, GOES TO SYMBL.
        INX                 ; SETS INDEX TO START OF
        INX                 ; OPERAND NUMBER.
        INX
        INX
        INX
        INX
        INX
        JSR     ASCBIN      ; CONVRTS # TO BINARY IN B-A.
ASM1B   STAB    ONDVAL      ; STORES OPERAND VALUE IN
        STAA    ONDVAL+1    ; ONDVAL.
;
;
;
; FOLLOWING FORMS THE VALUE FOR THE LABEL.
;
SYMBL   LDX     TMP1        ; LOADS ORIG LINE PTR INTO X.
        LDAA    0,X         ; LOADS SYMBOL (LABEL).
        LDAB    1,X         ; LOADS LABEL CONTROL CHAR.
        LDX     PCVAL       ; LABEL VALUE GETS PCVAL.
        STX     SYMVAL      ; .
        CMPB    #'='        ; TESTS IF LABLE IS EQUATED.
        BNE     ASM2        ; SKIPS IF NOT EQUATED.
        LDX     ONDVAL      ; LABEL VALUE (SYMVAL) GETS
        STX     SYMVAL      ; THE OPERAND VALUE.
        BRA     ASM3        ; CONTINUES EVALUATION.
ASM2    CMPB    #' '        ; TESTS FOR END-OF-PROGRAM.
        BEQ     ASM3        ; SKIPS IF SPACE (NOT END).
        TST     AR3         ; TESTS IF SECOND PASS.
        BEQ     ASM2A       ; EXITS IF SECOND PASS.
        RTS                 ; EXITS THE ASSEMBLER.
ASM2A   STAB    AR3         ; SETS CTR TO SECOND PASS.
        BRA     ASM1        ; GOES BACK FOR SECOND PASS.
;
;
;
; FOLLOWING PUTS THE LABEL VALUE IN THE SYMBOL TABLE.
;
ASM3    BSR     SYMPTR      ; X GETS SYMBL TABL ENTRY ADR. E
        LDAA    SYMVAL      ; STORES THE LABEL
        STAA    0,X         ; ADDRESS (SYMVAL) INTO THE
        LDAA    SYMVAL+1    ; SYMBOL TABEL.
        STAA    1,X

; FOLLOWING FORMS THE OPERATION CODE.
;
LDOP    LDX     TMP1        ; LOADS ORIG LINE POINTER.
        INX                 ; SETS X TO POINT TO
        INX                 ; THE OP CODE CHARS.
        INX
        LDAA    0,X         ; GETS OP CODE CHAR INTO A.
        CMPA    #' '        ; TESTS IF OP CODE EXISTS.
        BEQ     OPRND       ; SKIPS IF NONEXISTANT.
        JSR     ASCBIN      ; CONVRTS OP CODE TO BINARY.
        LDX     PCVAL       ; LOADS POINTR TO OBJECT CODE.
        STAA    0,X         ; STORS OP INTO OBJECT CODE.
        INX                 ; SETS TO NEXT OBJ CODE LOCTN.
        STX     PCVAL       ; SAVES P.C. POINTER.
;
;
;
; FOLLOWING STORES INTO THE OBJECT CODE THE SIZED OPERAND.
;
OPRND   LDX     TMP1        ; LOADS SOURCE LINE POINTER.
        LDAA    6,X         ; LOADS OPERAND SIZE CHAR.
        LDX     PCVAL       ; LOADS X WITH OBJ CODE PTR.
        CMPA    #'E'        ; TESTS LENGTH TYPE.
        BGT     RELTIV      ; SKIPS IF AN "R" OPERAND.
        BEQ     EXTEND      ; SKIPS IF AN "E" SIZE OPRND.
        CMPA    #'D'        ; TESTS IF SIZE CHR EXISTS.
        BEQ     DIRECT      ; SKIPS IF "D"COMND EXISTS.
;
;
;
; FOLLOWING GETS THE NEXT LINE.
;
ASM4    LDX     TMP1        ; LOADS START OF LINE IN
ASM4A   INX                 ; ORDER TO FIND NEXT LINE.
        LDAA    0,X         ; LOADS CHAR FROM SORCE LINE.
        CMPA    #$60        ; TESTS FOR A CARRAGE RETURN.
        BNE     ASM4A       ; SKIPS BAK UNTIL C.R. FOUND.
        INX                 ; POINTS TO FIRST LINE CHAR.
        BRA     ASM1A       ; GOES BACK TO ASSM. NEXT LINE
;
;
;
; THE FOLLOWING ARE SUBROUTINES USED BY THE MAIN CODE.
;
;
INDADR  BSR     SYMPTR      ; GETS CONTENTS OF
        LDX     0,X         ; SYMBOL LOCATION.
        STX     ONDVAL      ; STORES AS OPERAND.
        BRA     SYMBL       ; RETURNS TO FIX LABEL VALUE.
;
SYMPTR  ASLA                ; MULT LABEL BY 2 TO FORM
        CLRB                ; POINTR INTO SYMBOL TABLE.
LOADX   STAA    TMP+1       ; LOADS POINTER INTO THE
        STAB    TMP         ; SYMBOL TABLE INTO X.
        LDX     TMP         ; RETURNS TO CALLER.
        RTS                 ; RETURNS.

EXTEND  LDAB    ONDVAL      ; STORES HI BYTE OF OPERAND
        STAB    0,X         ; INTO OBJECT CODE.
        INX                 ; INC PC TO POINT TO NXT WD.
DIRECT  LDAA    ONDVAL+1    ; STORES LO BYTE OF OPERAND
        STAA    0,X         ; INTO OBJECT CODE.
        INX                 ; INC & SAVE P.C. TO POINT TO
        STX     PCVAL       ; NEXT BYTE.
        BRA     ASM4        ; GOES TO WORK ON NEXT LINE.
;
RELTIV  INX                 ; INCREMENT P.C. PTR TO POINT
        STX     PCVAL       ; TO NXT BYTE & SAVE P.C..
        LDAA    ONDVAL+1    ; LOADS LO BYTE OF OPERAND.
        SUBA    PCVAL+1     ; FORMS RELATIVE OFFSET.
        DEX                 ; INSERTS RELATIVE BYTE INTO
        STAA    0,X         ; OBJECT CODE.
        BRA     ASM4        ; GOES TO ASSMBL NEXT LINE.
;
;       END OF THE ASSEMBLER PROGRAM.
;
;@ THE SOURCE FILE FOR PDS-V3N APPEARS TO BE BROKEN UP INTO TWO SEPARATE FILES.
;@ I HAVE JOINED THEM TOGETHER FOR MY PURPOSES.
;@
;@ THIS DOES MEAN (HOWEVER) THAT THE LISTING LINE NUMBERS DO NOT MATCH.
;@
;@ AS A RESULT, THE LINE NUMBERS FOR THE DEBUGGER ITSELF HAVE 800 ADDED TO THEM
;@ WHEN COMPARED TO THE PDF LISTING FILES.
;@
;@ THE 'SPACER' COMMENTS ARE SIGNIFINED BY THE ';@' CHARACTERS.
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@
;@ THE DEBUGGER LISTING APPEARS TO START AT LINE 81.
;@ AS I HAVE ADDED 800 TO THE DEBUGGER LINES, THE RESULTING
;@ NEW LINE NUMBER IS 81 + 800 = 881. 
;@
;          DEBUGGER
;
;     THE DEBUGGER FOR THE PDS SYSTEM WAS DESIGNED TO
; PROVIDE A VERSATILE TOOL FOR USE IN PROGRAM TESTING AND
; DEBUGGING.  IT ALLOWS FOR BREAKPOINTS, MINI-ASSEMBLER
; SYMBOL TABLE REFERENCING, STACK MANIPULATION AND
; INPUT IN EITHER HEXADECIMAL, OCTAL OR DECIMAL.
; THE DEBUGGER PRINTS A PROMPT CHARACTER ">" ON EVERY NEW
; LINE.  AN INSTRUCTION CAN BE TYPED IN WHENEVER THE CURSOR
; IS BLINKING, EXCEPT WHEN A NUMBER IS BEING TYPED IN.
; THE DEBUGGER CALLS THE EDITOR WHENEVER A NUMBER IS TO BE
; INPUT, SO CORRECTIONS CAN BE MADE IF THE WRONG DIGIT IS
; TYPED IN.  THE POINTER "PCVAL" POINTS TO THE CURRENTLY
; OPENED BYTE LOCATION.  THE DEBUGGER OPERATES ON WHATEVER
; BYTE IS POINTED TO BY PCVAL.  FOR FURTHER DETAILS SEE THE
; SECTION ON THE DEBUGGER IN THE OPERATORS REFERENCE MANUAL.
;
;     THE DEBUGGER IS IMPLEMENTED BY A SMALL ROUTINE TO SET 
; UP ENTRY (DEBUG) AND A LARGE ROUTINE WHICH DOES A RANGE
; COMPARE TO FIND THE PROPER COMMAND AND THEN EXECUTES THE
; COMMAND (RUNBUG).  NOTE THAT SINCE COMMANDS ARE
; DIFFERENTIATED BY RANGE, ANY KEY STRUCK WILL PRODUCE
; A COMMAND EXECUTION, SUCH AS A "," BEING INTERPRETED
; AS A "+" COMMAND.
;
;
;
; COMMANDS:
;
; "C.R." LINE - PRINTS ">" OUT ON A NEW LINE.
; " " CHANGE - THE SPACE COMND CHANGES CONTENTS FROM Y TO X.
; "+" OPNNXT - OPENS NEXT LOCATION.
; "-" OPNPRE - OPENS PREVIOUS LOCATION.
; "^B" BRKSET - SETS A BREAKPOINT AT THE OPENED LOCATION.
; "^C" CLRBRK - CLEARS BRKPOINT. MUST BE DONE BEFORE EXIT.
; "^E" EXIT - PERFORM RTI - EXECUTE AT BRKPOINT LOCATION.
; "^G" GOLOCN - STARTS EXECUTION AT OPENED LOCATION.
; "^J" JUMP   - JUMP TO USERS SUBROUTINE.
; "^O" OPNLOC - OPENS LOCATION THAT IS TYPED IN AFTER "O".
; "^R" OPNREG - OPENS THE TOP-OF-STACK LOCATION.
; "^S" SETSTK - SETS THE STACK TO THE OPENED LOCATION.
; "^T" OPNTBL - OPENS LOCATION IN SYMBOL TABLE OF NEXT CHR
; "^X" GOEXEC - EXITS THE DEBUGGER - GOES BACK TO EXEC.
;
;
;
; SUBROUTINES:
;
; INPCHR - INPUTS A CHAR. INTO A AND PRINTS IT.
; INPNUM - INPUTS A NUMBER INTO B-A FROM THE KEYBOARD.
; PNTBYT - PRINTS ACC A AS 2 HEX DIGITS ON THE SCREEN.
; PNTDIG - PRINTS B-A AS 4 HEX DIGITS ON THE SCREEN.
; NEWLIN - PRINTS A C.R. AND A ">" ON THE SCREEN.
; DPSADR - PRINTS BYTE ADDRESS (XXXX) AND BYTE CONTENTS (YY)
;   AS >XXXX YY ON THE SCREEN.
;

;       ORG     $FE4A
;
;
;
;       FOLLOWING IS LOCATION OF ENTRY OF THE BRKPT VECTOR.
;
BKENTR  TSX                 ; INDEX GETS STACK POINTER.
        LDAB    5,X         ; LOADS HI RETURN ADDRESS.
        LDAA    6,X         ; LOADS LOW BYTE OF ADDRESS.
        SUBA    #1          ; SUB 1 FROM RETURN ADDRESS.
        SBCB    #0          ; .
        STAB    5,X         ; RESTORES RETURN ADDR. TO
        STAA    6,X         ; THE BREAKPOINT LOCATION.
        BRA     DEBUG       ; GOES TO THE DEBUGGER.
;
;
LINE    CMPA    #$0D        ; TESTS FOR A C.R. (LINE).
        BLT     JMPLCN      ; GOES TO 'JSR' (^J) ROUTNE.
        BGT     OPNREG      ; SKIPS FOR NEXT (^R) TESTS.
        JSR     SUB32       ; MOVES CURSOR UP ONE LINE.
POPLIN  INS                 ; CLEANS UP STACK FOR
        INS                 ; DISPLAY OF C.R. >.
;
;
DEBUG   BSR     NEWLIN      ; PRINTS "C.R.>".
DBUG1   BSR     INPCHR      ; READS IN COMMAND.
        JSR     RTARRO      ; INSERT BLANK.
        LDX     PCVAL       ; LOADS CURRENTLY OPENED LOC.
        BSR     RUNBUG      ; EXECUTES DEBUG COMMAND.
        BRA     DBUG1       ; GOES BACK FOR NEXT COMND.
;
;
INPCHR  JSR     GETCHR      ; READ IN CHAR INTO A.
        JSR     PUTCHR      ; DISPLAYS CHARACTER.
        RTS                 ; RETURNS TO CALLER.
;
;
;
RUNBUG  CMPA    #$03        ; TESTS FOR A "^C" COMMAND.
        BLT     BRKSET      ; SKIPS IF A "^B" COMMAND.
        BGT     EXIT        ; SKIPS FOR NEXT COMND TEST.
CLRBRK  LDX     BRKADR      ; GETS ADDRESS OF BREAKPOINT.
        LDAA    BRKSAV      ; LOADS ORIG BYTE CONTENTS.
        STAA    0,X         ; RESTORES BYTE DATA.
        BRA     DSPADR      ; GOES TO OPEN THE LOCATION.
;
;
CHANGE  CMPA    #' '        ; TESTS OFR A SPACE COMND.
        BLT     EXECTV      ; SKIPS TO EXIT BACK TO EXEC.
        BGT     OPNPRE      ; SKIPS FOR OTHER CMND TESTS.
SPACE   BSR     INPNUM      ; INPUTS NEW BYTE CONTENTS.
        LDX     PCVAL       ; LOADS OPENED BYTE LOCATION.
        STAA    0,X         ; STORES NEW BYTE CONTENTS.
;
;
OPNNXT  INX                 ; FORMS NEXT LOCATION ADDRES.
        BRA     DSPADR      ; GOES TO OPEN LOCATION BYTE.
        
OPNPRE  CMPA    #'-'        ; TESTS FOR A "-" COMMAND.
        BLT     OPNNXT      ; SKIPS FOR A "+" COMMAND.
        DEX                 ; FORMS PREV. LOCATION ADDR.
        BRA     DSPADR      ; GOES TO OPEN THE LOCATION.
;
;
EXECTV  INS                 ; CLEANS UP THE STACK.
        INS                 ; .
        JMP     EXEC        ; RETURNS TO THE EXECUTIVE.
;
;
BRKSET  LDAA    0,X         ; LOADS DATA OF OPNED LOCATN.
        STAA    BRKSAV      ; SAVES DATA OF OPNED BYTE.
        STX     BRKADR      ; SAVES ADDR. OF BREAKPOINT.
        LDAA    #$3F        ; LOADS SOFTWARE INTUP COMND.
        STAA    0,X         ; SETS AN SWI AT OPNED.BYTE.
        BRA     POPLIN      ; GOES TO NEXT LINE FOR COMND.
;
;
OPNREG  CMPA    #$12        ; TESTS FOR "^R" (STACK TOP).
        BLT     OPNLOC      ; GOES TO OPEN A LOCATION.
        BGT     OPNTBL      ; SKIPS FOR NEXT TEST (^T).
        TSX                 ; OPENS TOP-OF-STACK.
        INX                 ; PCVAL GETS STACK POINTER.
        INX                 ; (CLEANS UP THE STACK).
        BRA     DSPADR      ; GOES TO DISPLAY THE T-O-S.
;
;
SETSTK  TXS                 ; STACK POINTER GETS PCVAL.
        BRA     DEBUG       ; RETURNS TO INPUT COMMAND.
;
;
OPNLOC  BSR     INPNUM      ; LOADS A 16 BIT NUMBER.
OPNLC1  STAB    PCVAL       ; STORES NEWLY OPENED
        STAA    PCVAL+1     ; LOCATION ADDRESS.
        BRA     DSPAD1      ; DISPLAYS CONTNTS OF LOCATN.
;
;
EXIT    CMPA    #$07        ; TESTS IF AN EXIT (^E) COMD.
        BEQ     GOLOCN      ; SKIPS FOR THE "GO" COMMAND.
        BGT     LINE        ; SKIPS FOR NEXT COMMD TEST.
        INS                 ; CLEARS UP THE STACK.
        INS
        RTI                 ; RETURNS FROM BREAKPOINT.
;
;
OPNTBL  CMPA    #$14        ; TESTS IF A "^T" (TABLE).
        BLT     SETSTK      ; GOES TO SET STACK PTR (^S).
        BGT     CHANGE      ; SKIPS FOR NEXT TEST (SPACE).
        BSR     INPCHR      ; LOADS A WITH SYMBOL (LABL).
        ASLA                ; ALIGNS ADDRESS FOR
        CLRB                ; SYMBOL TABLE ENTRY.
        BRA     OPNLC1      ; SAVES AND DISPLAYS ADDRESS.
;
;
GOLOCN  INS                 ; CLEANS UP THE STACK.
        INS                 ; .
JMPLCN  JMP     0,X         ; JUMPS TO USERS PROGRAM.

;
; FOLLOWING ARE SUBROUTINES USED BY THE DEBUGGER.
;
NEWLIN  LDAA    #$0D        ; LOADS A CARRIAGE RETURN.
        BSR     PNTBF1      ; PRINTS A CARRIAGE RETURN.
        LDAA    #'>'        ; LOADS A PROMPT CHARACTER.
        BRA     PNTBF1      ; DISPLAYS PROMPTER CHAR.
;
;
; FOLLOWING INPUTS A 16 BIT NUMBER INTO THEE BA REGISTER.
;
INPNUM  JSR     EDITIN      ; INPUT A STRING OF DIGITS.
        LDX     SCNPTR      ; LOADS ADDR. OF FIRST DIGIT.
        BSR     ASCBIN      ; CONVERTS TO BINARY # ON BA.
        RTS                 ; RETURNS TO CALLER.
;
;
; FOLLOWING DISPLAYS THE LOCATION ADDR. & CONTENTS.
;
DSPADR  STX     PCVAL       ; SAVES OPENED LOCATION ADDR.
DSPAD1  BSR     NEWLIN      ; PRINTS A "C.R." AND ">".
        BSR     PNTDIG      ; PRINTS OUT "PCVAL" IN HEX.
        JSR     RTARRO      ; PRINTS A SPACE.
        LDX     PCVAL       ; LOADS PTR. TO OPEND LOC.
        LDAA    0,X         ; LOADS DATA FROM LOCATN.
        BSR     PNTBYT      ; PRINTS DATA IN HEX FORMAT.
        RTS                 ; RETURNS TO INPUT COMMAND.
;
;
PNTDIG  LDAA    PCVAL       ; PRINTS THE 2 HI HEX DIGITS
        BSR     PNTBYT      ; OF OPENED ADDRESS.
        LDAA    PCVAL+1     ; PRINTS OUT 2 LOW HEX DIGITS
;
;
; FOLLOWING PRINTS OUT 2 HEX DIGITS.
;
PNTBYT  LDX     #16         ; LOADS 16 FOR BASE.
        STX     ARB         ; STORES FOR CONVERSION.
        CLRB                ; CLEARS HI 2 DIGITS.
        LDX     #IOBUFF     ; LOADS OUTPUT BUFF ADDRESS.
;
;
; FOLLOWING CONVERTS BYTE TO HEX WITH LEADING ZEROS.
;
CONVRT  STAB    IOBUFF+1    ; CLERS BYTE FOR SECOND DIGIT..
        JSR     BINASC      ; CONVERTS TO ASCII DIGITS.
        LDAA    IOBUFF      ; LOADS HI DIGIT.
        LDAB    IOBUFF+1    ; TESTS BOTH DIGITS CONVTD.
        BNE     PNTBUF      ; SSKIPS IF BOTH DIGITS CONVTD
        STAA    IOBUFF+1    ; SETS UP LOW DIGIT.
        LDAA    #'0'        ; HIGH DIGIT GETS A "0".
;
PNTBUF  BSR     PNTBF1      ; PRINTS OUT HI DIGIT.
        LDAA    IOBUFF+1    ; LOADS LOW DIGI
PNTBF1  JSR     PUTCHR      ; DISPLAYS CCHARACTER.
        RTS                 ; RETURNS TO CALLING PROGRAM.
;
;       END OF DEBUGGER

;      UTILITY PROGRAMS
;
;
;
;
;          ASCII TO BINARY CONVERSION.
;
;     THE ASCII TO BINARY ROUTINE CONVERTS FROM AN ASCII
; NUMBER STRING POINTED TO BY X TO AN UNSIGNED 16 BIT
; BINARY NUMBER IN BA (ACC B HAS THE HI BYTE, ACC A HAS
; THE LO BYTE).  THE ASCII STRING IS TERMINATED BY A NON
; HEXADECIMAL CHARACTER.  UPON EXITING, THE INDEX REGISTER
; WILL POINT TO THE NEXT CHARACTER AFTER THE NUMBER
; STRING.  THE BASE OF THE NUMBER STRING IS PASSED TO
; THE ROUTINE IN ARA (ARA IS THE ARITHMETIC REGESTER A
; LOCATED IN BYTES 06 AND 07 OF LOW MEMORY).  IF THE
; ROUTINE IS ENTERED WITH A KNOWN BASE, PUT THE BASE
; (BETWEEN 2 AND 16) IN ARA AND ENTER THE ROUTINE AT
; THE ENTRY POINT ENTR2.
;
;
;
;     CONVERSION FORMULA:
; ASCII NUMBBER STRING X[4],X[3],X[2],X[1] IN
;BASE Y;
; BINARY NUMBER =
;     X[4]*Y^3+X[3]*Y^2+X[2]*Y^1+X[1]*Y^0 OR
; BINARY NUMBER =
;     (((0*Y+X[4])*Y+X[3])*Y+X[2])*Y+X[1]
;WHERE ^ IS THE EXPONENT OPERATOR,
; X IS A CHARACTER & Y IS THE BASE.
;
;
;
;     ALGORITHM:
;ASCBIN:  FORM THE BASE IN ARA BASED ON THE FIRST CHAR.
;  OF THE NUMBER STRING; INCREMENT CHAR. PTR. IN X;
;ENTR2:  NUMBER (IN BA) GETS 0;
;NXTCHR:  IF THE CURRENT CHAR. POINTED TO BY X IS NOT A
;  DIGIT THEN EXIT ELSE INCREMT CHARACTER PTR IN INDEX.
;  CONVERT DIGIT TO BINARY;
;  NUMBER GETS NUMBER * BASE;
;  NUMBER GETS NUMBER + DIGIT;
;  GO TO OPERATE ON THE NEXT DIGIT (NXTCHR),
;

ASCBIN  LDAA    0,X         ; GETS CHR TO FORM BASE.
        CMPA    #'.'        ; TESTS FOR DECML STRNG.
        BLT     OCT         ; SKIPS IF BASE 8 (*).
        BGT     HEX         ; SKIPS IF BASE 16.
        LDAA    #10         ; LOADS BASE 10 FOR CONVERSN.
        BRA     ASC1        ; SKIPS TO INC. TEXT POINTR.
OCT     LDAA    #8          ; LOADS BASE 8 FOR CONVERSION.
ASC1    INX                 ; INCREMENT PTR TO NEXT CHAR.
        BRA     ASC2        ; SKIPS TO SAVE BASE.
HEX     LDAA    #16         ; LOADS BASE 16 FOR CONVERN.
ASC2    STAA    AR0         ; SAVES BASE IN BASE#.
;
;
ENTR2   CLRB    NUMBER      ; GETS 0.
        PSHB                ; (LOW NUMBER ON STACK).
        STAB    AR1         ; CLEARS HI OF BASE.
NXTCHR  LDAA    0,X         ; GETS CHAR TO CONVERT.
        INX                 ; INC TO NEXT CHARACTER.
        CMPA    #'0'        ; TESTS FOR END-OF-STRING.
        BLT     AEXIT       ; EXITS IF END.
        SUBA    #'0'        ; FORMS B.C.D. NUMBER.
        CMPA    #10         ; TESTS IF DECIMAL DIGIT.
        BLT     ASC3        ; SKIPS IF DECIMAL.
        CMPA    #16         ; TESTS FOR END OF STRING.
        BLE     AEXIT       ; EXITS IF NOT A HEX DIGIT.
        SUBA    #7          ; FORMS A HEX B.C.D. DIGIT.
        CMPA    #16         ; TESTS FOR END OF STRING.
        BGE     AEXIT       ; EXITS IF CHAR > "F".
ASC3    STAA    DIGIT       ; SAVES DIGIT FOR ADD.
;
CNVASC  STX     TMP         ; SAVES INDEX REG FOR MULT.
        PULA                ; RESTORES LO OF "NUMBER".
        BSR     MULT        ; NUMBER GETS NUMBER * BASE.
        ADDA    DIGIT       ; NUMBER GETS NUMBER + DIGIT.
        ADCB    #0
        PSHA                ; SAVES LO OF NUMBER.
        LDX     TMP         ; RESTORES STRING POINTER.
        BRA     NXTCHR      ; GOES TO CONVRT NEXT CHAR.
AEXIT   PULA                ; REASTORES "NUMBER" IN BA.
        RTS                 ; RETURNS TO CALLING PROGRAM.

;          BINARY TO ASCII
;
;
;     THE BINARY TO ASCII CONVERSION ROUTINE CONVERTS
; A 16 BIT BINARY NUMBER IN THE BA REGISTR (REG B & REG A)
; TO A STRING OF ASCII DIGITS.  THE ASCII STRING CAN BE IN
; ANY BASE FROM BASE 2 THROUGH BASE 41.  THE VALUE OF THE
; BASE IS LOCATED IN THE ARITHMETIC PSEUDO-REGISTER ARB
; (ARB IS LOOCATED IN BYTE AR3 [LOC 4] AND AR2 [LOC 5]).
; WHEN THE ROUTINE IS ENTERED, THE POINTER TO THE OUTPUT
; LOCATION IS PASSED IN THE INDEX REG.  WHEN THE ROUTINE
; EXITS, THE INDEX POINTS TO THE LAST DIGIT IN THE STRING
; PLUS ONE.
;     CONVERSION IS DONE BY THE METHOD OF REPEATED
; DIVISION.  THE LOW ORDER DIGIT IS FORMED FIRST. THE
; DIGITS ARE THEN PLACED ON THE STACK UNTIL CONVERSION IS
; COMPLETED.  THE DIGITS ARE THEN POPPED OFF THE STACK
; AND PLACED ON THE OUTPUT STRING.  THE TOP-OF-STACK IS
; INITIALIZED TO HEX FF TO TELL WHEN ALL THE DIGITS
; HAVE BEEN POPPED OFF THE STACK.  AFTER THE DIVISION, THE
; DIGIT (THE REMAINDER OF THE DIVISION OPERATION)
; IS LOCATED IN THE AR 0 PART OF ARA (BYTE 7).  WHEN
; THE QUOTIENT OF THE DIVISION IS 0, THEN THE CONVERSION
; IS COMPLEATED.
;
;
;
BINASC  STX     TMP         ; SAVES OUTPUT POINTER.
        DES                 ; /SETS THE TOP-OF-STACK TO
        TSX                 ; /ALL ONES TO TELL END OF
        CLR     0,X         ; /CHAR STRING (LAST CHAR IS
        COM     0,X         ; /PUT ON STACK FIRST).
BIN1    LDX     ARB         ; RESTORES DIVISOR (BASE).
        STX     ARA
        BSR     DIVIDE      ; * QUOTIENT IN BA GETS THE
; REMAINDER OF # TO BE CONVERTED; REMAINDER IN ARA GETS
; THE LOW ORDER DIGIIT.
        STAA    TMP1        ; SAVES A OF BA.
        LDAA    AR0         ; LOAD DIGIT (REMAINDER).
        PSHA                ; STACK DIGIT (REVERSE ORDER). G
        LDAA    TMP1        ; RESTORES A OF BA.
        TSTA                ; /TESTS IF QUOTIENT IS = 0
        BNE     BIN1        ; /(SIGNIFYING THAT
        TSTB                ; /THE CONVERRSION
        BNE     BIN1        ; IS DONE).
;
BINSTR  LDX     TMP         ; RESTORES OUTPUT POINTER.
BIN3    PULA                ; UNSTACK A DIGIT.
        TSTA                ; TESTS IF NEG (END?).
        BPL     BIN4        ; SKIPS IF A DIGIT.
        RTS                 ; EXITS FROM SUBROUTINE.
BIN4    CMPA    #9          ; TESTS IF RESULT IS HEX.
        BLE     BIN5        ; SKIPS IF DIGIT NOT HEX.
        ADDA    #7          ; FORMS HEX VALUE OF DIGIT.
BIN5    ADDA    #'0'        ; FORMS DECIMAL CHARACTER.
        STAA    0,X         ; OUTPUTS CHARACTER.
        INX                 ; POINTS TO NEXT CHARACTER.
        BRA     BIN3        ; GOES BACK FOR NEXT DIGIT.

; MULTIPLY ROUTINE
;
;     THE MULTIPLY ROUTINE MULTIPLIES TWO 16 BIT BINARY
; NUMBERS TOGETHER TO PRODUCE A 16 BIT RESULT. THE BA
; REGISTERS AND ARA (BYTES 6 & 7) REGISTER ARE USED.
; THE CONTENTS OF ARA ARE UNCHANGED UPON PROGRAM EXIT.
;
;
;  BA GETS BA * ARA
;
;
;     MULTIPLYING IS ACCOMPLISHED BY REPEATED ADDITIONS
; OF ONE OF THE OPERATORS (OPERATOR ARA) INTO THE RESULT.
; THE RESULT STARTS OUT WITH A ZERO VALUE AND IS SHIFTED
; OVER ONE AFTER EACH ADDITION.  THE HIGHEST ORDER VALUE
; IS ADDED IN FIRST AND THEN, GOING TO THE RIGHT,
; (THUS SHIFTING THE ANSWER LEFT ONE TO BRING IN THE NEXT
; RIGHTMOST DIGIT) GETTING THE NEXT LOWERMOST SIGNIFICANT
; DIGIT.  THE NEXT RIGHTMOST BIT OF THE OTHER OPERAND
; (THE INE ORIGINALLY IN BA) IS TESTED, AND IF ONE,
; ANOTHER ADDITION TAKES PLACE.  THIS IS REPEATED UNTIL
; THE FINAL SUM IS FORMED.
;
;
;
;  MULTIPLY ALGORITHM:
;
;MULT:  STACK BA; BA GETS 0; SET COUNT VALUE TO 16;
;MUL1:  SHIFT BA LEFT 1;
;  SHIFT LEFT ORIG BA VALUE ON STACK INTO CARRY;
;  IF CARRY = 0 THEN GO TO MUL2
;  BA GETS BA + ARA;
;MUL2:  DECREMENT COUNT;
;  IF COUNT # 0 THEN GO TO MUL1 ELSE EXIT.
;
;
;
;
MULT    PSHA                ; PUTS THE ORIGINAL CONTENTS
        PSHB                ; OF BA ONTO THE STACK.
        LDAA    #16         ; LOADS COUNT VALUE
        PSHA                ; ONTO THE STACK.
        CLRA                ; BA GETS ZEROED.
        CLRB
        TSX                 ; SET INDEX TO STACK.
MUL1    ASLA                ; SHIFT LEFT BA.
        ROLB
        ASL     2,X         ; SHIFTS ORIG. BA OPERAND
        ROL     1,X         ; ONE LEFT INTO CARRY.
        BCC     MUL2        ; SKIPS ADDING IF CARRY = 0.
        ADDA    AR0         ; BA GETS BA + ARA.
        ADCB    AR1
MUL2    DEC     0,X         ; TESTS IF DONE.
        BNE     MUL1        ; GOES BACK IF NOT DONE.
        INS                 ; CLEANS UP THE STACK.
        INS
        INS
        RTS                 ; EXITS ROUTINE.

;          DIVIDE ROUTINE
;
;     THE DIVIDE SUBROUTINE DIVIDES THE 16 BIT NUMBER
; IN THE BA REGISTERS BY THE 16 BIT NUMBER IN THE PSEUDO
; REGISTER ARA (LOCATED IN BYTES 6 & 7).  UPON EXITING,
; BA WILL CONTAIN THE QUOTIENT OF THE DIVISION AND ARA
; WILL CONTAIN THE REMAINDER.  THE DIVIDEND BA IS DIVIDED
; BY THE DIVISOR ARA (I.E.  BA/ARA ).
;
;
;
;
;  DIVIDE ALGORITHM:
;
;DIVIDE:  X3,4 GETS BA (BA IS PUT ON THE STACK);
;  X1,2 GETS THE 16 BIT ARA VALUE (ARA PUT ON THE STACK);
;  COUNT GETS 1 + THE NUMBER OF NONSIGNIFICANT BITS IN
; THE DIVISOR [LEFT JUSTIFY X1,2 TO FIRST 1 BIT, COUNT
; GETS 1 + THE # OF LEADING ZEROS IN X1,2] [COUNT WILL BE
; FROM 1 TO 17];
;  BA GETS X3,4 [RESTORED BA];
;  X3,4 GETS 0 [INITIALIZES THE QUOTIENT];
;DIV3:  BA GETS B1 - X1,2;
;  IF THERE WAS A BORROW [I.E. DIVIDEND IN BA < DIVISOR
; IN X1,2 (ARA)] THEN BA GETS BA + X1,2 [ORIGINAL BA
; VALUE RESTORED] & CARRY CLEARED ELSE CARRY IS SET;
;DIV5:  X3,4 [QUOTIENT] GETS CARRY LEFT SHIFTED IN;
;  X1,2 [DIVISOR] GETS SHIFTED RIGHT ONE PLACE WITH ZERO
; FILLED IN FROM THE LEFT SIDE;
;  DECREMENT COUNT;
;  EXIT IF DONE ELSE GO TO DIV3;
;
;
;
;
;
DIVIDE  PSHA                ; LOADS DIVIDEND INTO X3,4.
        PSHB
        LDAA    AR1         ; LOADS DIVISOR FROM ARA.
        LDAB    AR0
        PSHB                ; PUTS DIVISOR INTO X1,2.
        PSHA
        DES                 ; SET UP SPACE FOR COUNT.
        TSX                 ; INDEX GETS STACK POINTER.
        LDAA    #1          ; INITIALIZE COUNT.
        TST     1,X         ; TESTS FOR HI DIVISR BIT ON
        BMI     DIV2        ; SKIPS IF ON.
DIV1    INCA                ; COUNTS LEADING ZEROS.
        ASL     2,X         ; LEFT JUSTIFIES X1,2.
        ROL     1,X
        BMI     DIV2        ; SKIPS IF NO LEADING ZERO.
        CMPA    #17         ; TESTS FOR ALL ZERO DIVISOR.
        BNE     DIV1        ; GOES BACK IF BITS LEFT.
DIV2    STAA    0,X         ; SETS COUNTER.
        LDAB    3,X         ; BA GETS ORIGINAL
        LDAA    4,X         ; DIVIDEND VALUE.
        CLR     3,X         ; CLEARS X3,4 FOR FORMATION
        CLR     4,x         ; OF QUOTIENT.
        
DIV3    SUBA    2,X         ; START OF DIVIDE LOOP.
        SBCB    1,X
        BCC     DIV4        ; SKIP IF DIVIDEND < DIVISOR.
        ADDA    2,X         ; RESTORES DIVIDEND IN BA.
        ADCB    1,X
        CLC                 ; CLEARS THE CARRY.
        BRA     DIV5        ; SKIPS WITH CARRY CLEAR.
DIV4    SEC                 ; SETS CARRY TO 1.
DIV5    ROL     4,X         ; SHIFTS CARRY INTO
        ROL     3,X         ; QUOTIENT X3,4
        LSR     1,X         ; SHIFTS DIVISOR X1,2
        ROR     2,X         ; RIGHT ONCE.
        DEC     0,X         ; DECREMENTS COUNTER.
        BNE     DIV3        ; GOES BACK IF NOT DONE.
        STAB    AR1         ; STORES REMAINDER IN ARA.
        STAA    AR0
        INS                 ; CLEANS UP THE STACK.
        INS
        INS
        PULB                ; STORES QUOTIENT IN BA.
        PULA
        RTS                 ; EXITS ROUTINE.
;
;
;
_IRQ    .DW      $0104       ; INTERRUPT REQUEST VECTOR.
_SWI    .DW      BKENTR      ; SOFTWARE INT. VECTOR ADDR.
_NMI    .DW      $0108       ; NON-MASKABLE-INT. VECT.
_RST    .DW      $FC00       ; RESTART VECTOR ADDRESS.
;
;
;
;  END OF PDS SOURCE LISTING.
;
;
END